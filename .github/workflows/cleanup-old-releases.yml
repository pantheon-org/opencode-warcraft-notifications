name: Cleanup Old Releases

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run - only show what would be deleted without actually deleting'
        required: false
        default: true
        type: boolean
  schedule:
    # Run weekly on Sundays at 2 AM UTC
    - cron: '0 2 * * 0'
  push:
    tags:
      - 'v*'
    # Also run after each new release is created

permissions:
  contents: write

jobs:
  cleanup-releases:
    name: Cleanup Old Releases
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cleanup old releases
        uses: actions/github-script@v7
        with:
          script: |
            const isDryRun = ${{ github.event.inputs.dry_run || 'true' }};
            
            console.log(`ğŸ§¹ Starting release cleanup (dry run: ${isDryRun})`);
            
            // Fetch all releases
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            console.log(`ğŸ“¦ Found ${releases.length} total releases`);
            
            // Parse and categorize releases by semantic version
            const releaseData = releases.map(release => {
              const match = release.tag_name.match(/^v?(\d+)\.(\d+)\.(\d+)(?:-(.+))?$/);
              if (!match) {
                console.log(`âš ï¸  Skipping invalid version format: ${release.tag_name}`);
                return null;
              }
              
              const [, major, minor, patch, prerelease] = match;
              return {
                release,
                major: parseInt(major, 10),
                minor: parseInt(minor, 10),
                patch: parseInt(patch, 10),
                prerelease: prerelease || null,
                version: `${major}.${minor}.${patch}`,
                tag: release.tag_name,
                created_at: new Date(release.created_at)
              };
            }).filter(Boolean);
            
            // Sort by version (newest first)
            releaseData.sort((a, b) => {
              if (a.major !== b.major) return b.major - a.major;
              if (a.minor !== b.minor) return b.minor - a.minor;
              if (a.patch !== b.patch) return b.patch - a.patch;
              if (a.prerelease && !b.prerelease) return 1;
              if (!a.prerelease && b.prerelease) return -1;
              return b.created_at - a.created_at;
            });
            
            console.log(`ğŸ“Š Parsed ${releaseData.length} valid releases`);
            
            // Group by major version
            const majorGroups = {};
            releaseData.forEach(item => {
              if (!majorGroups[item.major]) {
                majorGroups[item.major] = [];
              }
              majorGroups[item.major].push(item);
            });
            
            console.log(`ğŸ·ï¸  Found ${Object.keys(majorGroups).length} major version groups:`, Object.keys(majorGroups).map(k => `v${k}.x.x`));
            
            // Determine which releases to keep and delete
            const toKeep = [];
            const toDelete = [];
            
            // Keep up to 5 major versions (latest versions of each major)
            const majorVersions = Object.keys(majorGroups).map(Number).sort((a, b) => b - a);
            const majorsToKeep = majorVersions.slice(0, 5);
            const majorsToDelete = majorVersions.slice(5);
            
            console.log(`ğŸ“Œ Keeping major versions: ${majorsToKeep.map(v => `v${v}.x.x`).join(', ')}`);
            if (majorsToDelete.length > 0) {
              console.log(`ğŸ—‘ï¸  Deleting all releases from major versions: ${majorsToDelete.map(v => `v${v}.x.x`).join(', ')}`);
            }
            
            // For each major version we're keeping, apply different retention rules
            majorsToKeep.forEach((majorVersion, index) => {
              const releases = majorGroups[majorVersion];
              const isCurrentMajor = index === 0; // First in sorted array is the latest major
              
              if (isCurrentMajor) {
                // For current major: keep up to 10 minor/patch releases
                const keepCount = Math.min(10, releases.length);
                const releasesToKeep = releases.slice(0, keepCount);
                const releasesToDelete = releases.slice(keepCount);
                
                console.log(`ğŸ“¦ Current major v${majorVersion}: keeping ${keepCount}/${releases.length} releases`);
                
                toKeep.push(...releasesToKeep);
                toDelete.push(...releasesToDelete);
              } else {
                // For older majors: keep only the latest release of each major version
                const latestRelease = releases[0]; // Already sorted newest first
                const olderReleases = releases.slice(1);
                
                console.log(`ğŸ“¦ Older major v${majorVersion}: keeping 1/${releases.length} releases (latest only)`);
                
                toKeep.push(latestRelease);
                toDelete.push(...olderReleases);
              }
            });
            
            // Add all releases from major versions we're completely deleting
            majorsToDelete.forEach(majorVersion => {
              toDelete.push(...majorGroups[majorVersion]);
            });
            
            // Remove duplicates and sort
            const uniqueToDelete = [...new Set(toDelete)].sort((a, b) => a.created_at - b.created_at);
            
            console.log(`\nğŸ“Š Summary:`);
            console.log(`  âœ… Releases to keep: ${toKeep.length}`);
            console.log(`  ğŸ—‘ï¸  Releases to delete: ${uniqueToDelete.length}`);
            
            if (uniqueToDelete.length === 0) {
              console.log(`\nğŸ‰ No releases need to be deleted. All within limits!`);
              return;
            }
            
            console.log(`\nğŸ“‹ Releases to delete:`);
            uniqueToDelete.forEach(item => {
              console.log(`  - ${item.tag} (${item.version}) - created ${item.created_at.toISOString()}`);
            });
            
            if (isDryRun) {
              console.log(`\nğŸ” DRY RUN: No releases were actually deleted.`);
              console.log(`ğŸ’¡ To perform the actual cleanup, run this workflow with 'dry_run' set to false.`);
              return;
            }
            
            // Actually delete the releases
            console.log(`\nğŸ—‘ï¸ Starting deletion process...`);
            let deletedCount = 0;
            let errorCount = 0;
            
            for (const item of uniqueToDelete) {
              try {
                console.log(`ğŸ—‘ï¸ Deleting release: ${item.tag}`);
                
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: item.release.id
                });
                
                // Also delete the git tag if it exists
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `tags/${item.tag.replace(/^v/, 'v')}`
                  });
                  console.log(`ğŸ·ï¸ Deleted tag: ${item.tag}`);
                } catch (tagError) {
                  console.log(`âš ï¸ Could not delete tag ${item.tag}: ${tagError.message}`);
                }
                
                deletedCount++;
                
                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 500));
                
              } catch (error) {
                console.error(`âŒ Failed to delete release ${item.tag}: ${error.message}`);
                errorCount++;
              }
            }
            
            console.log(`\nâœ… Cleanup completed!`);
            console.log(`  ğŸ—‘ï¸ Successfully deleted: ${deletedCount} releases`);
            if (errorCount > 0) {
              console.log(`  âŒ Failed to delete: ${errorCount} releases`);
            }
            console.log(`  ğŸ“¦ Remaining releases: ${toKeep.length}`);

      - name: Summary
        if: always()
        run: |
          echo "ğŸ§¹ Release cleanup workflow completed"
          echo "ğŸ“… Workflow runs:"
          echo "  - Automatically: Every Sunday at 2 AM UTC"
          echo "  - After new releases: When tags are pushed"
          echo "  - Manually: Using workflow_dispatch"
          echo ""
          echo "ğŸ¯ Retention policy:"
          echo "  - Keep up to 5 major versions"
          echo "  - Keep up to 10 minor/patch releases for current major version only"
          echo "  - Keep only latest release for older major versions"
          echo ""
          echo "âš ï¸ Note: By default, this runs in dry-run mode."
          echo "ğŸ’¡ To actually delete releases, set 'dry_run' to false when running manually."