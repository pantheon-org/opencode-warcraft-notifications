name: Smart Version Bump

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Force version bump type'
        required: false
        type: choice
        options:
          - 'auto'
          - 'major'
          - 'minor'
          - 'patch'
        default: 'auto'

permissions:
  contents: write
  pull-requests: read
  actions: read

jobs:
  analyze-changes:
    name: Analyze Changes & Determine Version
    runs-on: ubuntu-latest
    outputs:
      should_bump: ${{ steps.decision.outputs.should_bump }}
      version_type: ${{ steps.decision.outputs.version_type }}
      new_version: ${{ steps.decision.outputs.new_version }}
      changelog: ${{ steps.decision.outputs.changelog }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Get commit history since last tag
        id: commits
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          
          if [ -z "$LATEST_TAG" ]; then
            # No tags found, get all commits
            COMMITS=$(git log --oneline --no-merges)
            echo "No previous tags found. Analyzing all commits."
          else
            # Get commits since last tag
            COMMITS=$(git log ${LATEST_TAG}..HEAD --oneline --no-merges)
            echo "Analyzing commits since ${LATEST_TAG}"
          fi
          
          # Save commits to file for AI analysis
          echo "$COMMITS" > commits.txt
          
          # Also get file changes
          if [ -z "$LATEST_TAG" ]; then
            git diff --name-status HEAD~10 HEAD > changes.txt 2>/dev/null || git ls-files > changes.txt
          else
            git diff --name-status ${LATEST_TAG}..HEAD > changes.txt
          fi
          
          echo "commits_count=$(echo "$COMMITS" | wc -l)" >> $GITHUB_OUTPUT

      - name: Install Google AI CLI (Gemini)
        run: |
          curl -o- https://generativelanguage.googleapis.com/install.sh | bash
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Analyze changes with AI
        id: ai-analysis
        env:
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_AI_API_KEY }}
        run: |
          # Create analysis prompt
          cat > analysis_prompt.txt << 'EOF'
          You are a semantic versioning expert. Analyze the following git commits and file changes to determine the appropriate version bump.
          
          Rules:
          - MAJOR: Breaking changes, API changes, major architecture changes
          - MINOR: New features, new functionality, backwards-compatible additions
          - PATCH: Bug fixes, documentation updates, small improvements, refactoring
          - NONE: Only CI/config changes, formatting, or no significant changes
          
          Consider:
          1. Commit messages and their conventional commit prefixes (feat:, fix:, BREAKING CHANGE:, etc.)
          2. File changes (new files, deleted files, modified core files)
          3. Overall impact of changes
          
          Commits:
          EOF
          
          cat commits.txt >> analysis_prompt.txt
          
          echo -e "\n\nFile Changes:" >> analysis_prompt.txt
          cat changes.txt >> analysis_prompt.txt
          
          echo -e "\n\nRespond with only one word: MAJOR, MINOR, PATCH, or NONE" >> analysis_prompt.txt
          
          # Use Gemini to analyze (fallback to simple analysis if API fails)
          if command -v gemini &> /dev/null && [ -n "$GOOGLE_API_KEY" ]; then
            AI_DECISION=$(gemini generate "$(cat analysis_prompt.txt)" 2>/dev/null | tail -1 | tr -d '\n\r' | tr '[:lower:]' '[:upper:]') || AI_DECISION=""
          else
            AI_DECISION=""
          fi
          
          # Fallback analysis based on conventional commits
          if [ -z "$AI_DECISION" ] || [[ ! "$AI_DECISION" =~ ^(MAJOR|MINOR|PATCH|NONE)$ ]]; then
            echo "AI analysis failed, using conventional commit analysis"
            if grep -qi "BREAKING CHANGE\|!:" commits.txt; then
              AI_DECISION="MAJOR"
            elif grep -qi "^feat\|^feature" commits.txt; then
              AI_DECISION="MINOR"  
            elif grep -qi "^fix\|^bugfix\|^patch" commits.txt; then
              AI_DECISION="PATCH"
            elif grep -qi "^docs\|^doc\|^chore\|^ci\|^build\|^style\|^refactor" commits.txt; then
              AI_DECISION="PATCH"
            else
              AI_DECISION="PATCH"
            fi
          fi
          
          echo "ai_decision=$AI_DECISION" >> $GITHUB_OUTPUT
          echo "AI decided: $AI_DECISION"

      - name: Make version decision
        id: decision
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Current version: $CURRENT_VERSION"
          
          # Use manual input if provided, otherwise use AI decision
          if [ "${{ github.event.inputs.version_type }}" != "auto" ] && [ -n "${{ github.event.inputs.version_type }}" ]; then
            VERSION_TYPE="${{ github.event.inputs.version_type }}"
            echo "Using manual version type: $VERSION_TYPE"
          else
            VERSION_TYPE=$(echo "${{ steps.ai-analysis.outputs.ai_decision }}" | tr '[:upper:]' '[:lower:]')
            echo "Using AI decision: $VERSION_TYPE"
          fi
          
          if [ "$VERSION_TYPE" = "none" ]; then
            echo "should_bump=false" >> $GITHUB_OUTPUT
            echo "No version bump needed"
            exit 0
          fi
          
          # Calculate new version
          IFS='.' read -r -a version_parts <<< "$CURRENT_VERSION"
          major=${version_parts[0]}
          minor=${version_parts[1]}
          patch=${version_parts[2]}
          
          case $VERSION_TYPE in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac
          
          NEW_VERSION="${major}.${minor}.${patch}"
          
          echo "should_bump=true" >> $GITHUB_OUTPUT
          echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Generate changelog
          CHANGELOG="## Changes in v${NEW_VERSION}\n\n"
          while IFS= read -r commit; do
            CHANGELOG="${CHANGELOG}- ${commit}\n"
          done < commits.txt
          
          echo "changelog=$CHANGELOG" >> $GITHUB_OUTPUT
          
          echo "Version will be bumped from $CURRENT_VERSION to $NEW_VERSION (type: $VERSION_TYPE)"

  create-tag:
    name: Create Version Tag
    runs-on: ubuntu-latest
    needs: analyze-changes
    if: needs.analyze-changes.outputs.should_bump == 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Create and push tag
        run: |
          NEW_VERSION="${{ needs.analyze-changes.outputs.new_version }}"
          
          # Check if tag already exists
          if git tag -l "v$NEW_VERSION" | grep -q "v$NEW_VERSION"; then
            echo "‚ö†Ô∏è Tag v$NEW_VERSION already exists - skipping tag creation"
            echo "This may happen if workflow is re-run or tag was manually created"
          else
            git tag -a "v$NEW_VERSION" -m "Release v$NEW_VERSION

          Version Type: ${{ needs.analyze-changes.outputs.version_type }}
          AI Analysis: ${{ needs.analyze-changes.outputs.ai_decision }}
          
          This tag will trigger:
          1. Package version sync via sync-package-version.yml
          2. NPM publishing via release-publish.yml"
            
            git push origin --tags
            echo "‚úÖ Created and pushed tag v$NEW_VERSION"
          fi

      - name: Summary
        run: |
          echo "üéØ Smart Version Bump Complete!"
          echo ""
          echo "üìä Analysis Results:"
          echo "  - Version Type: ${{ needs.analyze-changes.outputs.version_type }}"
          echo "  - New Version: ${{ needs.analyze-changes.outputs.new_version }}"
          echo "  - AI Decision: ${{ steps.ai-analysis.outputs.ai_decision }}"
          echo ""
          echo "üîÑ Next Steps (Automated):"
          echo "  1. ‚úÖ Tag v${{ needs.analyze-changes.outputs.new_version }} created"
          echo "  2. üîÑ sync-package-version.yml will sync package.json"
          echo "  3. üöÄ release-publish.yml will publish to npm"
          echo ""
          echo "Monitor workflow progress in the Actions tab."