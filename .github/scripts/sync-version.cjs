#!/usr/bin/env node

/**
 * Version sync script for package.json
 * Syncs package.json version with Git tags
 */

const { execSync } = require('child_process');
const { readFileSync, writeFileSync } = require('fs');

// Helper function to execute shell commands
function exec(command) {
  try {
    return execSync(command, { encoding: 'utf8', stdio: 'pipe' }).trim();
  } catch (error) {
    console.error(`Command failed: ${command}`);
    console.error(error.message);
    throw error;
  }
}

// Get environment variables
const { GITHUB_TOKEN, GITHUB_REPOSITORY, GITHUB_REF } = process.env;

// Validate required environment variables
if (!GITHUB_TOKEN || !GITHUB_REPOSITORY || !GITHUB_REF) {
  console.error('âŒ Missing required environment variables');
  process.exit(1);
}

// Extract tag from GITHUB_REF (refs/tags/v1.0.0)
const tagMatch = GITHUB_REF.match(/^refs\/tags\/(.+)$/);
if (!tagMatch) {
  console.error('âŒ Not triggered by a tag push');
  process.exit(1);
}

const tag = tagMatch[1];
const version = tag.replace(/^v/, '');

console.log(`ğŸ·ï¸ Processing tag: ${tag}`);
console.log(`ğŸ“¦ Extracted version: ${version}`);

async function main() {
  // Read current package.json
  let packageJson;
  try {
    packageJson = JSON.parse(readFileSync('package.json', 'utf8'));
  } catch (error) {
    console.error('âŒ Failed to read package.json');
    process.exit(1);
  }

  const currentVersion = packageJson.version;
  console.log(`ğŸ“‹ Current package.json version: ${currentVersion}`);
  console.log(`ğŸ¯ Target version: ${version}`);

  // Check if update is needed
  if (currentVersion === version) {
    console.log('âœ… Package.json version already matches tag version - no sync needed');
    return;
  }

  console.log('ğŸ“¦ Package.json needs version update');

  // Configure Git
  exec('git config --local user.email "action@github.com"');
  exec('git config --local user.name "GitHub Action"');

  // Create version sync branch
  const branchName = `sync-version/${tag}`;
  console.log(`ğŸŒ¿ Creating branch: ${branchName}`);

  exec(`git checkout -b "${branchName}"`);

  // Update package.json version
  packageJson.version = version;
  writeFileSync('package.json', JSON.stringify(packageJson, null, 2) + '\n');
  console.log(`âœï¸ Updated package.json version to: ${version}`);

  // Commit and push version sync
  exec('git add package.json');
  exec(`git commit -m "chore: sync package.json version to ${version}

Automatically generated by tag ${tag}

[skip ci]"`);

  exec(`git push origin "${branchName}"`);
  console.log(`ğŸš€ Pushed version sync to branch: ${branchName}`);

  // Create PR using GitHub CLI
  try {
    const prTitle = `chore: sync package.json version to ${version}`;
    const prBody = `## Version Sync

This PR automatically syncs the package.json version with the newly created Git tag.

- **Tag:** ${tag}
- **Version:** ${version}
- **Trigger:** Automated by tag creation workflow

### Changes
- Updates package.json version from ${currentVersion} to ${version}

### Auto-Merge
This PR will auto-merge once all required checks pass, as it's a simple version synchronization.

---
*This PR was automatically created by the Sync Package Version workflow.*`;

    const prResult = exec(
      `gh pr create --title "${prTitle}" --body "${prBody}" --base main --head "${branchName}"`,
    );
    console.log(`âœ… Created PR: ${prResult}`);

    // Try to enable auto-merge
    try {
      exec(`gh pr merge "${branchName}" --auto --squash`);
      console.log('ğŸ¯ Auto-merge enabled for PR');
    } catch (autoMergeError) {
      console.log('âš ï¸ Could not enable auto-merge (this is normal if auto-merge is not available)');
      console.log('The auto-merge-bot workflow will handle merging after checks pass.');
    }
  } catch (error) {
    console.error('âŒ Failed to create PR:', error.message);
    process.exit(1);
  }

  console.log('âœ… Version sync completed successfully!');
}

main().catch((error) => {
  console.error('âŒ Version sync failed:', error);
  process.exit(1);
});
