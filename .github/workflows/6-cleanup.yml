name: 6. Cleanup (Releases & Branches)

on:
  workflow_run:
    workflows: ['5. Publish Release (npm + Docs)']
    types: [completed]
  schedule:
    # Run weekly on Sundays at 2 AM UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run - show what would be deleted without deleting'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: read

jobs:
  # Job 1: Cleanup old releases
  cleanup-releases:
    name: Cleanup Old Releases
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd # v5.0.1

      - name: Setup Node.js
        uses: actions/setup-node@2028fbc5c25fe9cf00d9f06a71cc4710d4507903 # v6.0.0
        with:
          node-version: '20'

      - name: Cleanup old releases
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const isDryRun = ${{ github.event.inputs.dry_run || 'true' }};

            console.log(`ğŸ§¹ Starting release cleanup (dry run: ${isDryRun})`);

            // Fetch all releases
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            console.log(`ğŸ“¦ Found ${releases.length} total releases`);

            // Parse and categorize releases
            const releaseData = releases.map(release => {
              const match = release.tag_name.match(/^v?(\d+)\.(\d+)\.(\d+)(?:-(.+))?$/);
              if (!match) {
                console.log(`âš ï¸  Skipping invalid version: ${release.tag_name}`);
                return null;
              }
              
              const [, major, minor, patch, prerelease] = match;
              return {
                release,
                major: parseInt(major, 10),
                minor: parseInt(minor, 10),
                patch: parseInt(patch, 10),
                prerelease: prerelease || null,
                version: `${major}.${minor}.${patch}`,
                tag: release.tag_name,
                created_at: new Date(release.created_at)
              };
            }).filter(Boolean);

            // Sort by version (newest first)
            releaseData.sort((a, b) => {
              if (a.major !== b.major) return b.major - a.major;
              if (a.minor !== b.minor) return b.minor - a.minor;
              if (a.patch !== b.patch) return b.patch - a.patch;
              if (a.prerelease && !b.prerelease) return 1;
              if (!a.prerelease && b.prerelease) return -1;
              return b.created_at - a.created_at;
            });

            console.log(`ğŸ“Š Parsed ${releaseData.length} valid releases`);

            // Group by major version
            const majorGroups = {};
            releaseData.forEach(item => {
              if (!majorGroups[item.major]) {
                majorGroups[item.major] = [];
              }
              majorGroups[item.major].push(item);
            });

            console.log(`ğŸ·ï¸  Found ${Object.keys(majorGroups).length} major versions`);

            // Determine what to keep and delete
            const toKeep = [];
            const toDelete = [];

            // Keep up to 5 major versions
            const majorVersions = Object.keys(majorGroups).map(Number).sort((a, b) => b - a);
            const majorsToKeep = majorVersions.slice(0, 5);
            const majorsToDelete = majorVersions.slice(5);

            console.log(`ğŸ“Œ Keeping majors: ${majorsToKeep.map(v => `v${v}.x.x`).join(', ')}`);
            if (majorsToDelete.length > 0) {
              console.log(`ğŸ—‘ï¸  Deleting majors: ${majorsToDelete.map(v => `v${v}.x.x`).join(', ')}`);
            }

            // Apply retention rules
            majorsToKeep.forEach((majorVersion, index) => {
              const releases = majorGroups[majorVersion];
              const isCurrentMajor = index === 0;
              
              if (isCurrentMajor) {
                // Keep up to 10 releases for current major
                const keepCount = Math.min(10, releases.length);
                toKeep.push(...releases.slice(0, keepCount));
                toDelete.push(...releases.slice(keepCount));
                console.log(`ğŸ“¦ Current v${majorVersion}: keeping ${keepCount}/${releases.length}`);
              } else {
                // Keep only latest for older majors
                toKeep.push(releases[0]);
                toDelete.push(...releases.slice(1));
                console.log(`ğŸ“¦ Older v${majorVersion}: keeping 1/${releases.length}`);
              }
            });

            // Add all releases from deleted majors
            majorsToDelete.forEach(majorVersion => {
              toDelete.push(...majorGroups[majorVersion]);
            });

            const uniqueToDelete = [...new Set(toDelete)];

            console.log(`\nğŸ“Š Summary:`);
            console.log(`  âœ… Keep: ${toKeep.length}`);
            console.log(`  ğŸ—‘ï¸  Delete: ${uniqueToDelete.length}`);

            if (uniqueToDelete.length === 0) {
              console.log(`\nğŸ‰ No releases to delete!`);
              return;
            }

            console.log(`\nğŸ“‹ Releases to delete:`);
            uniqueToDelete.forEach(item => {
              console.log(`  - ${item.tag} (${item.version})`);
            });

            if (isDryRun) {
              console.log(`\nğŸ” DRY RUN: No deletions performed.`);
              return;
            }

            // Delete releases
            console.log(`\nğŸ—‘ï¸ Deleting releases...`);
            let deleted = 0;

            for (const item of uniqueToDelete) {
              try {
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: item.release.id
                });
                
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `tags/${item.tag.replace(/^v/, 'v')}`
                  });
                } catch (e) {
                  console.log(`âš ï¸ Could not delete tag ${item.tag}`);
                }
                
                deleted++;
                await new Promise(resolve => setTimeout(resolve, 500));
              } catch (error) {
                console.error(`âŒ Failed to delete ${item.tag}`);
              }
            }

            console.log(`\nâœ… Deleted ${deleted} releases`);

  # Job 2: Cleanup merged branches
  cleanup-branches:
    name: Cleanup Merged Branches
    runs-on: ubuntu-latest
    needs: cleanup-releases

    steps:
      - name: Checkout repository
        uses: actions/checkout@93cb6efe18208431cddfb8368fd83d5badbf9bfd # v5.0.1
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup merged branches
        run: |
          echo "ğŸŒ¿ Cleaning up merged branches..."
          git fetch --all --prune

          # Find merged branches
          MERGED_BRANCHES=$(git branch -r --merged origin/main | \
            grep -v 'origin/main' | \
            grep -v 'origin/HEAD' | \
            grep -v 'origin/docs' | \
            sed 's/origin\///' | xargs)

          if [ -z "$MERGED_BRANCHES" ]; then
            echo "âœ… No merged branches to clean up"
            exit 0
          fi

          echo "Found merged branches: $MERGED_BRANCHES"

          for branch in $MERGED_BRANCHES; do
            # Skip protected branches
            if [[ "$branch" =~ ^(main|master|develop|staging|production|docs)$ ]]; then
              echo "â­ï¸ Skipping protected: $branch"
              continue
            fi
            
            # Check branch age
            BRANCH_AGE=$(git log -1 --format="%ct" "origin/$branch" 2>/dev/null || echo "0")
            CURRENT_TIME=$(date +%s)
            AGE_DAYS=$(( (CURRENT_TIME - BRANCH_AGE) / 86400 ))
            
            if [ $AGE_DAYS -lt 1 ]; then
              echo "â­ï¸ Skipping recent: $branch (${AGE_DAYS}d old)"
              continue
            fi
            
            echo "ğŸ—‘ï¸ Deleting: $branch"
            git push origin --delete "$branch" || echo "âš ï¸ Failed to delete $branch"
          done

          # Cleanup local tracking branches
          git remote prune origin
          git branch -vv | grep ': gone]' | awk '{print $1}' | xargs -r git branch -D || true

          echo "âœ… Branch cleanup complete"

  # Summary job
  summary:
    name: Cleanup Summary
    runs-on: ubuntu-latest
    needs: [cleanup-releases, cleanup-branches]
    if: always()

    steps:
      - name: Display summary
        run: |
          echo "ğŸ§¹ Cleanup Workflow Complete!"
          echo ""
          echo "Results:"
          echo "  ğŸ“¦ Releases: ${{ needs.cleanup-releases.result }}"
          echo "  ğŸŒ¿ Branches: ${{ needs.cleanup-branches.result }}"
          echo ""
          echo "ğŸ“… Schedule:"
          echo "  - After each release (automatic)"
          echo "  - Weekly on Sundays at 2 AM UTC"
          echo "  - Manual via workflow_dispatch"
          echo ""
          echo "ğŸ“ Retention Policy:"
          echo "  - Keep 5 most recent major versions"
          echo "  - Keep 10 releases for current major"
          echo "  - Keep 1 release for older majors"
          echo "  - Delete branches merged >1 day ago"
